#!/usr/bin/env bash
set -o pipefail

# To-do:
# * learn to link .home/dot/**{!.inb?} files

############################################################
# General support functions

die()  { echo -e >&2 ".home ERROR:" "$@"; exit 1; }
idie() { echo -e >&2 ".home INTERNAL ERROR: " "$@"; exit 99; }
warn() { echo -e >&2 ".home WARNING:" "$@"; }

save_ifs() { oldifs="$IFS"; IFS="$1"; }
restore_ifs() { IFS="$oldifs"; }

for_each_module() {
    [[ -n $2 ]] || idie 'for_each_module: bad params'
    local modules="$1";     shift
    local f="$1";           shift
    local module
    for module in $modules; do
        [[ $module =~ ^[A-Za-z0-9_-]+$ ]] || continue
        $f "$@" "$module" || return 1
    done
}

############################################################
# update pass

find_updater_for() {
    local path_to_module="$1"
    [[ -x $path_to_module/dh/update ]] && { echo dh/update; return 0; }
    git --git-dir="$path_to_module/.git" \
        rev-parse --no-revs --quiet 2>/dev/null --verify @{upstream} \
        && { echo 'fetch_status_rebase_updater'; return 0; }
}

fetch_status_rebase_updater() {
    git fetch -q    || return 1
    git status -bs  || return 1
    git rebase -q   || { git rebase --abort 2>/dev/null; return 1; }
}

run_update_module() {
    local module="$1"
    echo "===== $module"
    (  cd "$module"
       $(find_updater_for "$(pwd -P)") || true
    )
}

run_update_pass() {
    for_each_module \* run_update_module
}

############################################################
# dependency pass

run_dependencies_pass() {
    local modules_before=$(for_each_module \* echo)

    cat_deps() { cat "$1/dh/dependencies" 2>/dev/null || true; }
    < <( for_each_module \* cat_deps \
         | decomment | sort -u \
         | deps_remove_existing . \
         | deps_conflict_check) \
           deps_command_generator
    for cmd in "${deps_commands[@]}"; do (eval "$cmd"); done

    [[ $modules_before == $(for_each_module \* echo) ]] || run_dependencies_pass
}

decomment() {
    sed 's/^ *//;               # Remove leading spaces
         s/^#.*//;              # Remove comments at beginning of line
         s/ * #.*//;            # Remove space-lead comments in line
         /^$/d;                 # Remove empty lines
         '
}

deps_remove_existing() {
    local dh_dir="$1" module rest
    while read module rest; do
        [[ -d $dh_dir/$module ]] && continue
        echo "$module $rest"
    done
}

deps_conflict_check() {
    local module rest prev
    while read module rest; do
        [[ $module == $prev ]] \
            && { warn "Duplicate module dependency: $module"; continue; }
        prev="$module"
        echo "$module $rest"
    done
}

declare -a deps_commands
deps_command_generator() {
    deps_commands=()
    local module type args
    while read module type args; do
        local e="echo ===== $module"
        case "$type" in
            git)    deps_commands+=("$e; git clone '$args' '$module'");;
            *)      deps_commands+=("$e; warn 'Unknown dependency type: $type'")
                    ;;
        esac
    done
}

############################################################
# buildmsg pass

run_buildmsg_pass() {
    echo "===== Building files"
}

############################################################
# inb4 passes

declare inb4_comment_char='#'
inb4_find_comment_char() {
    inb4_comment_char="$(sed -n '/^\(.\) :inb4:/{s//\1/p;q;}')"
    [[ -n $inb4_comment_char ]] || inb4_comment_char='#'
}

declare -a inb4_sorted
inb4_sort() {
    inb4_sorted=()
    while read line; do
        inb4_sorted+=("$line");
    done < <(
        for path in "$@"; do echo "${path: -1} $path"; done \
            | sort -n -s \
            | sed -e 's/^..//' \
        )
}

inb4_cat() {
    inb4_sort "$@"

    #   We can't use `head -q` here because that will break with BSD
    #   head(1). However, the extra `==> dir/filename <==` lines that
    #   get printed should cause no harm, since it's very unlikely
    #   that any *.inb4 filenames would have the `:inb4:` tag in them.
    inb4_find_comment_char < <(head -n 10 "${inb4_sorted[@]}")
    local c="$inb4_comment_char"
    local prefix="$c$c$c$c$c"

    echo "$prefix This file was generated by inb4."
    for file in "${inb4_sorted[@]}"; do
        echo; echo "$prefix $file"
        cat "$file"
    done

    echo
    echo "$prefix End of inb4 generated content."
}

inb4_check_file_conflicts() {
    local output
    while read output; do
        local     built=",inb4/$output"
        local installed="_inb4/$output"

        if [ ! -e "$installed" ]; then
            echo "$output"
        elif cmp -s "$built" "$installed"; then
            echo "$output"
        elif [ ! -e "$built" ]; then
            warn "$output has no previously built version to check"
        else
            warn "$output has been changed from version built by inb4"
        fi
    done
}

find_inb4_in_module() {
    find "$1" -name '*.inb[0-9]'
}

# The `inb4check` pass makes no changes, just checks for error and
# conflicts and produces the list of output files we need to generate
# under the `,inb4` pseudo-module.
#
inb4check_has_run=false
declare -a inb4_outputs
run_inb4check_pass() {
    local oldifs="$IFS"; IFS=$'\n'
    inb4_outputs=($(
        for_each_module \* find_inb4_in_module \
        | sed -es,[^/]*/,, -e 's,\.inb[0-9]$,,' \
        | sort -u \
        | inb4_check_file_conflicts
    ))
    IFS="$oldifs"
    inb4check_has_run=true
}

run_inb4build_pass() {
    $inb4check_has_run || {
        warn 'Must run inb4check pass before inb4build pass'
        return
    }
    local output
    for output in "${inb4_outputs[@]}"; do
        mkdir -p "$(dirname ",inb4/$output")" "$(dirname "_inb4/$output")"
        inb4_cat */"$output".inb[0-9] > ",inb4/$output"
        cp ",inb4/$output" "_inb4/$output"
    done
}

############################################################
# symlink pass

#  Input lines: path including module (e.g., `MODULE/bin/prog`)
# Output lines: input, install path (e.g., `MODULE/bin/prog\nbin/prog`)
#
add_local_dest() {
    sed -n -e 'p; s,^[^/]*/,.local/,p'
}

#  Input lines: "dot" path including module, e.g., `MODULE/dot/ssh/config`
# Output lines: input, install path, e.g. `MODULE/dot/ssh/config\n.ssh/config`
add_dot_dest() {
    sed -e 'p; s,^[^/]*/dot/,.,; s,^[^/]*/dot$,.,; '
}

# Produce the relative target path for a symlink from dest to src
symlink_rel_target() {
    local src="$1" dest="$2"
    local slashes="${dest//[^\/]/}"         # Leave only slashes...
    echo "${slashes//\//../}.home/$src"
}


canonicalize_dots() {
    save_ifs '/'

    local -a output=()
    for component in $1; do
        case "$component" in
        '')     ;;
        .)      ;;
        ..)     if    [ "${#output[@]}" -eq 0 ] \
                   || [ "${output[${#output[@]} -1]}" = '..' ]
                then
                    output+=("$component")
                else
                    unset "output[${#output[@]} - 1]"
                fi
                ;;
        *)      output+=("$component");;
        esac
    done

    local leading_slash trailing_slash
    [ "${1:0:1}" = / ] && leading_slash=/
    [ "${1: -1}" = / ] && trailing_slash=/
    echo "$leading_slash${output[*]}$trailing_slash"

    restore_ifs
}

link_target() {
    local target="$(readlink "$1")"
    if [ "${target:0:1}" = / ]; then
        canonicalize_dots "$target"
    else
        canonicalize_dots "$(dirname "$1")/$target"
    fi
}

run_symlink_pass() {
    for_each_module \* run_symlink_module
}

run_symlink_module() {
    [[ -n $1 && -z $2 ]] || idie "run_symlink_module: bad params"
    local module="$1"

    while read src; do
        read dest
        target="$(symlink_rel_target "$src" "$dest")"
        # check if dest is dangling link into .home
        if [ -L ../"$dest" ]; then
            # Remove dangling links into ~/.home/
            link_target="$(link_target "$HOME/$dest")"
            [[ "$link_target" =~ ^$HOME/.home/ ]] \
                && [ ! -e "$link_target" ] \
                && rm -f ../"$dest"
        fi
        if [ -d "$src" ]; then
            mkdir -p "../$dest" 2>/dev/null || warn "Conflict: .home/$src/"
        elif [ -f "$src" ]; then
            [ "$(readlink "../$dest")" = "$target" ] && continue
            ln -s "$target" "../$dest" 2>/dev/null \
                || warn "Conflict: .home/$src"
        else
            : # Ignore anything that's not a dir or file.
        fi
    done < <( find "$module/bin"  "$module/share" 2>/dev/null \
                  ! -regex '.*\.inb[0-9]' \
                  | sort | add_local_dest; \
              find "$module/dot" 2>/dev/null ! -regex '.*\.inb[0-9]' \
                  | sort | add_dot_dest; \
              )
}

############################################################
# Other passes

# This whole pass can be removed in a few months when everybody who was
# using previous versions has run this pass at least once.
#
run_clean_legacy_bin_pass() {
    # This is safe because it removes only symlinks targeting
    # `../.home/*`, these should never have been created by anything
    # but this script, and even if they were created by something
    # else, it was wrong to do so. :-)
    #
    find ~/bin -lname '../.home/*' -delete 2>/dev/null || true

    [[ "$PATH" =~ /\.local/bin ]] || warn '.local/bin not found in $PATH'
}

############################################################
# run setup scripts pass

run_setup_pass() {
    echo "===== Running dh/setup scripts"
    for module in *; do
        [[ -e $module/dh/setup ]] || continue
        echo "----- $module"
        (cd "$module" && dh/setup) || warn "Failure exit with $?"
    done
}

############################################################
# Main

do_update=false
passes=()
while [ -n "$1" ]; do case "$1" in
    --define-functions-only)    return 0; exit 0;;
    -p)                         passes+=("$2"); shift; shift;;
    -u)                         do_update=true; shift;;
    *)                          die "Unknown argument: $1";;
esac; done
[ -z "$passes" ] && passes=(
    dependencies buildmsg inb4check inb4build symlink clean_legacy_bin setup)
$do_update       && passes=("update" "${passes[@]}");

cd "$HOME"/.home/ 2>/dev/null || die "Cannot change to $HOME/.home/."
for p in "${passes[@]}"; do
    run_${p}_pass
done
