#!/usr/bin/env bash
set -o pipefail

# To-do:
# * learn to link .home/dot/**{!.inb?} files

############################################################
# General support functions

die()  { echo -e >&2 ".home ERROR:" "$@"; exit 1; }
idie() { echo -e >&2 ".home INTERNAL ERROR: " "$@"; exit 99; }
warn() { echo -e >&2 ".home WARNING:" "$@"; }

save_ifs() { oldifs="$IFS"; IFS="$1"; }
restore_ifs() { IFS="$oldifs"; }

for_each_module() {
    [[ -n $2 ]] || idie 'for_each_module: bad params'
    local modules="$1";     shift
    local f="$1";           shift
    local module
    for module in $modules; do
        [[ $module =~ ^[A-Za-z0-9_-]+$ ]] || continue
        $f "$@" "$module" || return 1
    done
}

############################################################
# update pass

find_updater_for() {
    local path_to_module="$1"
    [[ -x $path_to_module/dh/update ]] && { echo dh/update; return 0; }
    git --git-dir="$path_to_module/.git" \
        rev-parse --no-revs --quiet 2>/dev/null --verify @{upstream} \
        && { echo 'git pull'; return 0; }
}

run_update_module() {
    local module="$1"
    echo "===== $module"
    (  cd "$module"
       $(find_updater_for "$(/bin/pwd -P)") || true
    )
}

run_update_pass() {
    for_each_module \* run_update_module
}

############################################################
# dependency pass

run_dependencies_pass() {
    local modules_before=$(for_each_module \* echo)

    cat_deps() { cat "$1/dh/dependencies" 2>/dev/null || true; }
    < <( for_each_module \* cat_deps \
         | decomment | sort -u \
         | deps_remove_existing . \
         | deps_conflict_check) \
           deps_command_generator
    for cmd in "${deps_commands[@]}"; do (eval "$cmd"); done

    [[ $modules_before == $(for_each_module \* echo) ]] || run_dependencies_pass
}

decomment() {
    sed 's/^ *//;               # Remove leading spaces
         s/^#.*//;              # Remove comments at beginning of line
         s/ * #.*//;            # Remove space-lead comments in line
         /^$/d;                 # Remove empty lines
         '
}

deps_remove_existing() {
    local dh_dir="$1" module rest
    while read module rest; do
        [[ -d $dh_dir/$module ]] && continue
        echo "$module $rest"
    done
}

deps_conflict_check() {
    local module rest prev
    while read module rest; do
        [[ $module == $prev ]] \
            && { warn "Duplicate module dependency: $module"; continue; }
        prev="$module"
        echo "$module $rest"
    done
}

declare -a deps_commands
deps_command_generator() {
    deps_commands=()
    local module type args
    while read module type args; do
        local e="echo ===== $module"
        case "$type" in
            git)    deps_commands+=("$e; git clone '$args' '$module'");;
            *)      deps_commands+=("$e; warn 'Unknown dependency type: $type'")
                    ;;
        esac
    done
}

############################################################
# inb4 passes

declare -a inb4_sorted
inb4_sort() {
    inb4_sorted=()
    while read line; do
        inb4_sorted+=("$line");
    done < <(
        for path in "$@"; do echo "${path: -1} $path"; done \
            | sort -n --stable \
            | sed -e 's/^..//' \
        )
}

inb4_cat() {
    inb4_sort "$@"
    echo '##### This file was generated by inb4.'
    for file in "${inb4_sorted[@]}"; do
        echo; echo "##### $file"
        cat "$file"
    done
}

inb4_check_file_conflicts() {
    local output
    while read output; do
        local     built=",inb4/$output"
        local installed="_inb4/$output"

        if [ ! -e "$installed" ]; then
            echo "$output"
        elif cmp -s "$built" "$installed"; then
            echo "$output"
        elif [ ! -e "$built" ]; then
            warn "$output has no previously built version to check"
        else
            warn "$output has been changed from version built by inb4"
        fi
    done
}

find_inb4_in_module() {
    find "$1" -name '*.inb[0-9]'
}

inb4check_has_run=false
declare -a inb4_outputs
run_inb4check_pass() {
    local oldifs="$IFS"; IFS=$'\n'
    inb4_outputs=($(
        for_each_module \* find_inb4_in_module \
        | sed -es,[^/]*/,, -e 's,\.inb[0-9]$,,' \
        | sort -u \
        | inb4_check_file_conflicts
    ))
    IFS="$oldifs"
    inb4check_has_run=true
}

run_inb4build_pass() {
    $inb4check_has_run || {
        warn 'Must run inb4check pass before inb4build pass'
        return
    }
    local output
    for output in "${inb4_outputs[@]}"; do
        mkdir -p "$(dirname ",inb4/$output")" "$(dirname "_inb4/$output")"
        inb4_cat */"$output".inb[0-9] > ",inb4/$output"
        cp ",inb4/$output" "_inb4/$output"
    done
}

############################################################
# symlink pass

#  Input lines: path including module (e.g., `MODULE/bin/prog`)
# Output lines: input, install path (e.g., `MODULE/bin/prog\nbin/prog`)
#
add_local_dest() {
    sed -n -e 'p; s,^[^/]*/,.local/,p'
}

#  Input lines: "dot" path including module, e.g., `MODULE/dot/ssh/config`
# Output lines: input, install path, e.g. `MODULE/dot/ssh/config\n.ssh/config`
add_dot_dest() {
    sed -e 'p; s,^[^/]*/dot/,.,; s,^[^/]*/dot$,.,; '
}

# Produce the relative target path for a symlink from dest to src
symlink_rel_target() {
    local src="$1" dest="$2"
    local slashes="${dest//[^\/]/}"         # Leave only slashes...
    echo "${slashes//\//../}.home/$src"
}


canonicalize_dots() {
    save_ifs '/'

    local -a output=()
    for component in $1; do
        case "$component" in
        '')     ;;
        .)      ;;
        ..)     if    [ "${#output[@]}" -eq 0 ] \
                   || [ "${output[${#output[@]} -1]}" = '..' ]
                then
                    output+=("$component")
                else
                    unset "output[${#output[@]} - 1]"
                fi
                ;;
        *)      output+=("$component");;
        esac
    done

    local leading_slash trailing_slash
    [ "${1:0:1}" = / ] && leading_slash=/
    [ "${1: -1}" = / ] && trailing_slash=/
    echo "$leading_slash${output[*]}$trailing_slash"

    restore_ifs
}

link_target() {
    local target="$(readlink "$1")"
    if [ "${target:0:1}" = / ]; then
        canonicalize_dots "$target"
    else
        canonicalize_dots "$(dirname "$1")/$target"
    fi
}

run_symlink_pass() {
    for_each_module \* run_symlink_module
}

run_symlink_module() {
    [[ -n $1 && -z $2 ]] || idie "run_symlink_module: bad params"
    local module="$1"

    while read src; do
        read dest
        target="$(symlink_rel_target "$src" "$dest")"
        # check if dest is dangling link into .home
        if [ -L ../"$dest" ]; then
            # Remove dangling links into ~/.home/
            link_target="$(link_target "$HOME/$dest")"
            [[ "$link_target" =~ ^$HOME/.home/ ]] \
                && [ ! -e "$link_target" ] \
                && rm -f ../"$dest"
        fi
        if [ -d "$src" ]; then
            mkdir -p "../$dest" 2>/dev/null || warn "Conflict: .home/$src/"
        elif [ -f "$src" ]; then
            [ "$(readlink "../$dest")" = "$target" ] && continue
            ln -s "$target" "../$dest" 2>/dev/null \
                || warn "Conflict: .home/$src"
        else
            : # Ignore anything that's not a dir or file.
        fi
    done < <( find "$module/bin" ! -regex '.*\.inb[0-9]' 2>/dev/null \
                  | sort | add_local_dest; \
              find "$module/dot" 2>/dev/null ! -regex '.*\.inb[0-9]' \
                  | sort | add_dot_dest; \
              )
}

############################################################
# Other passes

# This whole pass can be removed in a few months when everybody who was
# using previous versions has run this pass at least once.
#
run_clean_legacy_bin_pass() {
    # This is safe because it removes only symlinks targeting
    # `../.home/*`, these should never have been created by anything
    # but this script, and even if they were created by something
    # else, it was wrong to do so. :-)
    #
    find ~/bin -lname '../.home/*' -delete 2>/dev/null || true

    [[ "$PATH" =~ /\.local/bin ]] || warn '.local/bin not found in $PATH'
}

############################################################
# Main

do_update=false
passes=()
while [ -n "$1" ]; do case "$1" in
    --define-functions-only)    return 0; exit 0;;
    -p)                         passes+=("$2"); shift; shift;;
    -u)                         do_update=true; shift;;
    *)                          die "Unknown argument: $1";;
esac; done
[ -z "$passes" ] && passes=(
    dependencies inb4check inb4build symlink clean_legacy_bin)
$do_update       && passes=("update" "${passes[@]}");

cd "$HOME"/.home/ 2>/dev/null || die "Cannot change to $HOME/.home/."
for p in "${passes[@]}"; do
    run_${p}_pass
done
